{"mappings":"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","sources":["<anon>","../node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire4270\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"iTnlJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $dc0f79ca3b6ad5d8$export$2e2bcd8739ae039);\n// nb. This is for IE10 and lower _only_.\nvar $dc0f79ca3b6ad5d8$var$supportCustomEvent = window.CustomEvent;\nif (!$dc0f79ca3b6ad5d8$var$supportCustomEvent || typeof $dc0f79ca3b6ad5d8$var$supportCustomEvent === \"object\") {\n    $dc0f79ca3b6ad5d8$var$supportCustomEvent = function CustomEvent(event, x) {\n        x = x || {};\n        var ev = document.createEvent(\"CustomEvent\");\n        ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);\n        return ev;\n    };\n    $dc0f79ca3b6ad5d8$var$supportCustomEvent.prototype = window.Event.prototype;\n}\n/**\n * Dispatches the passed event to both an \"on<type>\" handler as well as via the\n * normal dispatch operation. Does not bubble.\n *\n * @param {!EventTarget} target\n * @param {!Event} event\n * @return {boolean}\n */ function $dc0f79ca3b6ad5d8$var$safeDispatchEvent(target, event) {\n    var check = \"on\" + event.type.toLowerCase();\n    if (typeof target[check] === \"function\") target[check](event);\n    return target.dispatchEvent(event);\n}\n/**\n * @param {Element} el to check for stacking context\n * @return {boolean} whether this el or its parents creates a stacking context\n */ function $dc0f79ca3b6ad5d8$var$createsStackingContext(el) {\n    while(el && el !== document.body){\n        var s = window.getComputedStyle(el);\n        var invalid = function(k, ok) {\n            return !(s[k] === undefined || s[k] === ok);\n        };\n        if (s.opacity < 1 || invalid(\"zIndex\", \"auto\") || invalid(\"transform\", \"none\") || invalid(\"mixBlendMode\", \"normal\") || invalid(\"filter\", \"none\") || invalid(\"perspective\", \"none\") || s[\"isolation\"] === \"isolate\" || s.position === \"fixed\" || s.webkitOverflowScrolling === \"touch\") return true;\n        el = el.parentElement;\n    }\n    return false;\n}\n/**\n * Finds the nearest <dialog> from the passed element.\n *\n * @param {Element} el to search from\n * @return {HTMLDialogElement} dialog found\n */ function $dc0f79ca3b6ad5d8$var$findNearestDialog(el) {\n    while(el){\n        if (el.localName === \"dialog\") return /** @type {HTMLDialogElement} */ el;\n        if (el.parentElement) el = el.parentElement;\n        else if (el.parentNode) el = el.parentNode.host;\n        else el = null;\n    }\n    return null;\n}\n/**\n * Blur the specified element, as long as it's not the HTML body element.\n * This works around an IE9/10 bug - blurring the body causes Windows to\n * blur the whole application.\n *\n * @param {Element} el to blur\n */ function $dc0f79ca3b6ad5d8$var$safeBlur(el) {\n    // Find the actual focused element when the active element is inside a shadow root\n    while(el && el.shadowRoot && el.shadowRoot.activeElement)el = el.shadowRoot.activeElement;\n    if (el && el.blur && el !== document.body) el.blur();\n}\n/**\n * @param {!NodeList} nodeList to search\n * @param {Node} node to find\n * @return {boolean} whether node is inside nodeList\n */ function $dc0f79ca3b6ad5d8$var$inNodeList(nodeList, node) {\n    for(var i = 0; i < nodeList.length; ++i){\n        if (nodeList[i] === node) return true;\n    }\n    return false;\n}\n/**\n * @param {HTMLFormElement} el to check\n * @return {boolean} whether this form has method=\"dialog\"\n */ function $dc0f79ca3b6ad5d8$var$isFormMethodDialog(el) {\n    if (!el || !el.hasAttribute(\"method\")) return false;\n    return el.getAttribute(\"method\").toLowerCase() === \"dialog\";\n}\n/**\n * @param {!DocumentFragment|!Element} hostElement\n * @return {?Element}\n */ function $dc0f79ca3b6ad5d8$var$findFocusableElementWithin(hostElement) {\n    // Note that this is 'any focusable area'. This list is probably not exhaustive, but the\n    // alternative involves stepping through and trying to focus everything.\n    var opts = [\n        \"button\",\n        \"input\",\n        \"keygen\",\n        \"select\",\n        \"textarea\"\n    ];\n    var query = opts.map(function(el) {\n        return el + \":not([disabled])\";\n    });\n    // TODO(samthor): tabindex values that are not numeric are not focusable.\n    query.push('[tabindex]:not([disabled]):not([tabindex=\"\"])'); // tabindex != \"\", not disabled\n    var target = hostElement.querySelector(query.join(\", \"));\n    if (!target && \"attachShadow\" in Element.prototype) {\n        // If we haven't found a focusable target, see if the host element contains an element\n        // which has a shadowRoot.\n        // Recursively search for the first focusable item in shadow roots.\n        var elems = hostElement.querySelectorAll(\"*\");\n        for(var i = 0; i < elems.length; i++)if (elems[i].tagName && elems[i].shadowRoot) {\n            target = $dc0f79ca3b6ad5d8$var$findFocusableElementWithin(elems[i].shadowRoot);\n            if (target) break;\n        }\n    }\n    return target;\n}\n/**\n * Determines if an element is attached to the DOM.\n * @param {Element} element to check\n * @return {boolean} whether the element is in DOM\n */ function $dc0f79ca3b6ad5d8$var$isConnected(element) {\n    return element.isConnected || document.body.contains(element);\n}\n/**\n * @param {!Event} event\n * @return {?Element}\n */ function $dc0f79ca3b6ad5d8$var$findFormSubmitter(event) {\n    if (event.submitter) return event.submitter;\n    var form = event.target;\n    if (!(form instanceof HTMLFormElement)) return null;\n    var submitter = $dc0f79ca3b6ad5d8$var$dialogPolyfill.formSubmitter;\n    if (!submitter) {\n        var target = event.target;\n        var root = \"getRootNode\" in target && target.getRootNode() || document;\n        submitter = root.activeElement;\n    }\n    if (!submitter || submitter.form !== form) return null;\n    return submitter;\n}\n/**\n * @param {!Event} event\n */ function $dc0f79ca3b6ad5d8$var$maybeHandleSubmit(event) {\n    if (event.defaultPrevented) return;\n    var form = /** @type {!HTMLFormElement} */ event.target;\n    // We'd have a value if we clicked on an imagemap.\n    var value = $dc0f79ca3b6ad5d8$var$dialogPolyfill.imagemapUseValue;\n    var submitter = $dc0f79ca3b6ad5d8$var$findFormSubmitter(event);\n    if (value === null && submitter) value = submitter.value;\n    // There should always be a dialog as this handler is added specifically on them, but check just\n    // in case.\n    var dialog = $dc0f79ca3b6ad5d8$var$findNearestDialog(form);\n    if (!dialog) return;\n    // Prefer formmethod on the button.\n    var formmethod = submitter && submitter.getAttribute(\"formmethod\") || form.getAttribute(\"method\");\n    if (formmethod !== \"dialog\") return;\n    event.preventDefault();\n    if (value != null) // nb. we explicitly check against null/undefined\n    dialog.close(value);\n    else dialog.close();\n}\n/**\n * @param {!HTMLDialogElement} dialog to upgrade\n * @constructor\n */ function $dc0f79ca3b6ad5d8$var$dialogPolyfillInfo(dialog) {\n    this.dialog_ = dialog;\n    this.replacedStyleTop_ = false;\n    this.openAsModal_ = false;\n    // Set a11y role. Browsers that support dialog implicitly know this already.\n    if (!dialog.hasAttribute(\"role\")) dialog.setAttribute(\"role\", \"dialog\");\n    dialog.show = this.show.bind(this);\n    dialog.showModal = this.showModal.bind(this);\n    dialog.close = this.close.bind(this);\n    dialog.addEventListener(\"submit\", $dc0f79ca3b6ad5d8$var$maybeHandleSubmit, false);\n    if (!(\"returnValue\" in dialog)) dialog.returnValue = \"\";\n    if (\"MutationObserver\" in window) {\n        var mo = new MutationObserver(this.maybeHideModal.bind(this));\n        mo.observe(dialog, {\n            attributes: true,\n            attributeFilter: [\n                \"open\"\n            ]\n        });\n    } else {\n        // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also\n        // seem to fire even if the element was removed as part of a parent removal. Use the removed\n        // events to force downgrade (useful if removed/immediately added).\n        var removed = false;\n        var cb = (function() {\n            removed ? this.downgradeModal() : this.maybeHideModal();\n            removed = false;\n        }).bind(this);\n        var timeout;\n        var delayModel = function(ev) {\n            if (ev.target !== dialog) return;\n             // not for a child element\n            var cand = \"DOMNodeRemoved\";\n            removed |= ev.type.substr(0, cand.length) === cand;\n            window.clearTimeout(timeout);\n            timeout = window.setTimeout(cb, 0);\n        };\n        [\n            \"DOMAttrModified\",\n            \"DOMNodeRemoved\",\n            \"DOMNodeRemovedFromDocument\"\n        ].forEach(function(name) {\n            dialog.addEventListener(name, delayModel);\n        });\n    }\n    // Note that the DOM is observed inside DialogManager while any dialog\n    // is being displayed as a modal, to catch modal removal from the DOM.\n    Object.defineProperty(dialog, \"open\", {\n        set: this.setOpen.bind(this),\n        get: dialog.hasAttribute.bind(dialog, \"open\")\n    });\n    this.backdrop_ = document.createElement(\"div\");\n    this.backdrop_.className = \"backdrop\";\n    this.backdrop_.addEventListener(\"mouseup\", this.backdropMouseEvent_.bind(this));\n    this.backdrop_.addEventListener(\"mousedown\", this.backdropMouseEvent_.bind(this));\n    this.backdrop_.addEventListener(\"click\", this.backdropMouseEvent_.bind(this));\n}\n$dc0f79ca3b6ad5d8$var$dialogPolyfillInfo.prototype = /** @type {HTMLDialogElement.prototype} */ {\n    get dialog () {\n        return this.dialog_;\n    },\n    /**\n   * Maybe remove this dialog from the modal top layer. This is called when\n   * a modal dialog may no longer be tenable, e.g., when the dialog is no\n   * longer open or is no longer part of the DOM.\n   */ maybeHideModal: function() {\n        if (this.dialog_.hasAttribute(\"open\") && $dc0f79ca3b6ad5d8$var$isConnected(this.dialog_)) return;\n        this.downgradeModal();\n    },\n    /**\n   * Remove this dialog from the modal top layer, leaving it as a non-modal.\n   */ downgradeModal: function() {\n        if (!this.openAsModal_) return;\n        this.openAsModal_ = false;\n        this.dialog_.style.zIndex = \"\";\n        // This won't match the native <dialog> exactly because if the user set top on a centered\n        // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's\n        // possible to polyfill this perfectly.\n        if (this.replacedStyleTop_) {\n            this.dialog_.style.top = \"\";\n            this.replacedStyleTop_ = false;\n        }\n        // Clear the backdrop and remove from the manager.\n        this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);\n        $dc0f79ca3b6ad5d8$var$dialogPolyfill.dm.removeDialog(this);\n    },\n    /**\n   * @param {boolean} value whether to open or close this dialog\n   */ setOpen: function(value) {\n        if (value) this.dialog_.hasAttribute(\"open\") || this.dialog_.setAttribute(\"open\", \"\");\n        else {\n            this.dialog_.removeAttribute(\"open\");\n            this.maybeHideModal(); // nb. redundant with MutationObserver\n        }\n    },\n    /**\n   * Handles mouse events ('mouseup', 'mousedown', 'click') on the fake .backdrop element, redirecting them as if\n   * they were on the dialog itself.\n   *\n   * @param {!Event} e to redirect\n   */ backdropMouseEvent_: function(e) {\n        if (!this.dialog_.hasAttribute(\"tabindex\")) {\n            // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be\n            // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this\n            // would not be needed - clicks would move the implicit cursor there.\n            var fake = document.createElement(\"div\");\n            this.dialog_.insertBefore(fake, this.dialog_.firstChild);\n            fake.tabIndex = -1;\n            fake.focus();\n            this.dialog_.removeChild(fake);\n        } else this.dialog_.focus();\n        var redirectedEvent = document.createEvent(\"MouseEvents\");\n        redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n        this.dialog_.dispatchEvent(redirectedEvent);\n        e.stopPropagation();\n    },\n    /**\n   * Focuses on the first focusable element within the dialog. This will always blur the current\n   * focus, even if nothing within the dialog is found.\n   */ focus_: function() {\n        // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.\n        var target = this.dialog_.querySelector(\"[autofocus]:not([disabled])\");\n        if (!target && this.dialog_.tabIndex >= 0) target = this.dialog_;\n        if (!target) target = $dc0f79ca3b6ad5d8$var$findFocusableElementWithin(this.dialog_);\n        $dc0f79ca3b6ad5d8$var$safeBlur(document.activeElement);\n        target && target.focus();\n    },\n    /**\n   * Sets the zIndex for the backdrop and dialog.\n   *\n   * @param {number} dialogZ\n   * @param {number} backdropZ\n   */ updateZIndex: function(dialogZ, backdropZ) {\n        if (dialogZ < backdropZ) throw new Error(\"dialogZ should never be < backdropZ\");\n        this.dialog_.style.zIndex = dialogZ;\n        this.backdrop_.style.zIndex = backdropZ;\n    },\n    /**\n   * Shows the dialog. If the dialog is already open, this does nothing.\n   */ show: function() {\n        if (!this.dialog_.open) {\n            this.setOpen(true);\n            this.focus_();\n        }\n    },\n    /**\n   * Show this dialog modally.\n   */ showModal: function() {\n        if (this.dialog_.hasAttribute(\"open\")) throw new Error(\"Failed to execute 'showModal' on dialog: The element is already open, and therefore cannot be opened modally.\");\n        if (!$dc0f79ca3b6ad5d8$var$isConnected(this.dialog_)) throw new Error(\"Failed to execute 'showModal' on dialog: The element is not in a Document.\");\n        if (!$dc0f79ca3b6ad5d8$var$dialogPolyfill.dm.pushDialog(this)) throw new Error(\"Failed to execute 'showModal' on dialog: There are too many open modal dialogs.\");\n        if ($dc0f79ca3b6ad5d8$var$createsStackingContext(this.dialog_.parentElement)) console.warn(\"A dialog is being shown inside a stacking context. This may cause it to be unusable. For more information, see this link: https://github.com/GoogleChrome/dialog-polyfill/#stacking-context\");\n        this.setOpen(true);\n        this.openAsModal_ = true;\n        // Optionally center vertically, relative to the current viewport.\n        if ($dc0f79ca3b6ad5d8$var$dialogPolyfill.needsCentering(this.dialog_)) {\n            $dc0f79ca3b6ad5d8$var$dialogPolyfill.reposition(this.dialog_);\n            this.replacedStyleTop_ = true;\n        } else this.replacedStyleTop_ = false;\n        // Insert backdrop.\n        this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);\n        // Focus on whatever inside the dialog.\n        this.focus_();\n    },\n    /**\n   * Closes this HTMLDialogElement. This is optional vs clearing the open\n   * attribute, however this fires a 'close' event.\n   *\n   * @param {string=} opt_returnValue to use as the returnValue\n   */ close: function(opt_returnValue) {\n        if (!this.dialog_.hasAttribute(\"open\")) throw new Error(\"Failed to execute 'close' on dialog: The element does not have an 'open' attribute, and therefore cannot be closed.\");\n        this.setOpen(false);\n        // Leave returnValue untouched in case it was set directly on the element\n        if (opt_returnValue !== undefined) this.dialog_.returnValue = opt_returnValue;\n        // Triggering \"close\" event for any attached listeners on the <dialog>.\n        var closeEvent = new $dc0f79ca3b6ad5d8$var$supportCustomEvent(\"close\", {\n            bubbles: false,\n            cancelable: false\n        });\n        $dc0f79ca3b6ad5d8$var$safeDispatchEvent(this.dialog_, closeEvent);\n    }\n};\nvar $dc0f79ca3b6ad5d8$var$dialogPolyfill = {};\n$dc0f79ca3b6ad5d8$var$dialogPolyfill.reposition = function(element) {\n    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n    var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;\n    element.style.top = Math.max(scrollTop, topValue) + \"px\";\n};\n$dc0f79ca3b6ad5d8$var$dialogPolyfill.isInlinePositionSetByStylesheet = function(element) {\n    for(var i = 0; i < document.styleSheets.length; ++i){\n        var styleSheet = document.styleSheets[i];\n        var cssRules = null;\n        // Some browsers throw on cssRules.\n        try {\n            cssRules = styleSheet.cssRules;\n        } catch (e) {}\n        if (!cssRules) continue;\n        for(var j = 0; j < cssRules.length; ++j){\n            var rule = cssRules[j];\n            var selectedNodes = null;\n            // Ignore errors on invalid selector texts.\n            try {\n                selectedNodes = document.querySelectorAll(rule.selectorText);\n            } catch (e) {}\n            if (!selectedNodes || !$dc0f79ca3b6ad5d8$var$inNodeList(selectedNodes, element)) continue;\n            var cssTop = rule.style.getPropertyValue(\"top\");\n            var cssBottom = rule.style.getPropertyValue(\"bottom\");\n            if (cssTop && cssTop !== \"auto\" || cssBottom && cssBottom !== \"auto\") return true;\n        }\n    }\n    return false;\n};\n$dc0f79ca3b6ad5d8$var$dialogPolyfill.needsCentering = function(dialog) {\n    var computedStyle = window.getComputedStyle(dialog);\n    if (computedStyle.position !== \"absolute\") return false;\n    // We must determine whether the top/bottom specified value is non-auto.  In\n    // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but\n    // Firefox returns the used value. So we do this crazy thing instead: check\n    // the inline style and then go through CSS rules.\n    if (dialog.style.top !== \"auto\" && dialog.style.top !== \"\" || dialog.style.bottom !== \"auto\" && dialog.style.bottom !== \"\") return false;\n    return !$dc0f79ca3b6ad5d8$var$dialogPolyfill.isInlinePositionSetByStylesheet(dialog);\n};\n/**\n * @param {!Element} element to force upgrade\n */ $dc0f79ca3b6ad5d8$var$dialogPolyfill.forceRegisterDialog = function(element) {\n    if (window.HTMLDialogElement || element.showModal) console.warn(\"This browser already supports <dialog>, the polyfill may not work correctly\", element);\n    if (element.localName !== \"dialog\") throw new Error(\"Failed to register dialog: The element is not a dialog.\");\n    new $dc0f79ca3b6ad5d8$var$dialogPolyfillInfo(/** @type {!HTMLDialogElement} */ element);\n};\n/**\n * @param {!Element} element to upgrade, if necessary\n */ $dc0f79ca3b6ad5d8$var$dialogPolyfill.registerDialog = function(element) {\n    if (!element.showModal) $dc0f79ca3b6ad5d8$var$dialogPolyfill.forceRegisterDialog(element);\n};\n/**\n * @constructor\n */ $dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager = function() {\n    /** @type {!Array<!dialogPolyfillInfo>} */ this.pendingDialogStack = [];\n    var checkDOM = this.checkDOM_.bind(this);\n    // The overlay is used to simulate how a modal dialog blocks the document.\n    // The blocking dialog is positioned on top of the overlay, and the rest of\n    // the dialogs on the pending dialog stack are positioned below it. In the\n    // actual implementation, the modal dialog stacking is controlled by the\n    // top layer, where z-index has no effect.\n    this.overlay = document.createElement(\"div\");\n    this.overlay.className = \"_dialog_overlay\";\n    this.overlay.addEventListener(\"click\", (function(e) {\n        this.forwardTab_ = undefined;\n        e.stopPropagation();\n        checkDOM([]); // sanity-check DOM\n    }).bind(this));\n    this.handleKey_ = this.handleKey_.bind(this);\n    this.handleFocus_ = this.handleFocus_.bind(this);\n    this.zIndexLow_ = 100000;\n    this.zIndexHigh_ = 100150;\n    this.forwardTab_ = undefined;\n    if (\"MutationObserver\" in window) this.mo_ = new MutationObserver(function(records) {\n        var removed = [];\n        records.forEach(function(rec) {\n            for(var i = 0, c; c = rec.removedNodes[i]; ++i){\n                if (!(c instanceof Element)) continue;\n                else if (c.localName === \"dialog\") removed.push(c);\n                removed = removed.concat(c.querySelectorAll(\"dialog\"));\n            }\n        });\n        removed.length && checkDOM(removed);\n    });\n};\n/**\n * Called on the first modal dialog being shown. Adds the overlay and related\n * handlers.\n */ $dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager.prototype.blockDocument = function() {\n    document.documentElement.addEventListener(\"focus\", this.handleFocus_, true);\n    document.addEventListener(\"keydown\", this.handleKey_);\n    this.mo_ && this.mo_.observe(document, {\n        childList: true,\n        subtree: true\n    });\n};\n/**\n * Called on the first modal dialog being removed, i.e., when no more modal\n * dialogs are visible.\n */ $dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager.prototype.unblockDocument = function() {\n    document.documentElement.removeEventListener(\"focus\", this.handleFocus_, true);\n    document.removeEventListener(\"keydown\", this.handleKey_);\n    this.mo_ && this.mo_.disconnect();\n};\n/**\n * Updates the stacking of all known dialogs.\n */ $dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager.prototype.updateStacking = function() {\n    var zIndex = this.zIndexHigh_;\n    for(var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i){\n        dpi.updateZIndex(--zIndex, --zIndex);\n        if (i === 0) this.overlay.style.zIndex = --zIndex;\n    }\n    // Make the overlay a sibling of the dialog itself.\n    var last = this.pendingDialogStack[0];\n    if (last) {\n        var p = last.dialog.parentNode || document.body;\n        p.appendChild(this.overlay);\n    } else if (this.overlay.parentNode) this.overlay.parentNode.removeChild(this.overlay);\n};\n/**\n * @param {Element} candidate to check if contained or is the top-most modal dialog\n * @return {boolean} whether candidate is contained in top dialog\n */ $dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {\n    while(candidate = $dc0f79ca3b6ad5d8$var$findNearestDialog(candidate)){\n        for(var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i){\n            if (dpi.dialog === candidate) return i === 0; // only valid if top-most\n        }\n        candidate = candidate.parentElement;\n    }\n    return false;\n};\n$dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {\n    var target = event.composedPath ? event.composedPath()[0] : event.target;\n    if (this.containedByTopDialog_(target)) return;\n    if (document.activeElement === document.documentElement) return;\n    event.preventDefault();\n    event.stopPropagation();\n    $dc0f79ca3b6ad5d8$var$safeBlur(/** @type {Element} */ target);\n    if (this.forwardTab_ === undefined) return;\n     // move focus only from a tab key\n    var dpi = this.pendingDialogStack[0];\n    var dialog = dpi.dialog;\n    var position = dialog.compareDocumentPosition(target);\n    if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n        if (this.forwardTab_) // forward\n        dpi.focus_();\n        else if (target !== document.documentElement) // backwards if we're not already focused on <html>\n        document.documentElement.focus();\n    }\n    return false;\n};\n$dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {\n    this.forwardTab_ = undefined;\n    if (event.keyCode === 27) {\n        event.preventDefault();\n        event.stopPropagation();\n        var cancelEvent = new $dc0f79ca3b6ad5d8$var$supportCustomEvent(\"cancel\", {\n            bubbles: false,\n            cancelable: true\n        });\n        var dpi = this.pendingDialogStack[0];\n        if (dpi && $dc0f79ca3b6ad5d8$var$safeDispatchEvent(dpi.dialog, cancelEvent)) dpi.dialog.close();\n    } else if (event.keyCode === 9) this.forwardTab_ = !event.shiftKey;\n};\n/**\n * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are\n * removed and immediately readded don't stay modal, they become normal.\n *\n * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed\n */ $dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {\n    // This operates on a clone because it may cause it to change. Each change also calls\n    // updateStacking, which only actually needs to happen once. But who removes many modal dialogs\n    // at a time?!\n    var clone = this.pendingDialogStack.slice();\n    clone.forEach(function(dpi) {\n        if (removed.indexOf(dpi.dialog) !== -1) dpi.downgradeModal();\n        else dpi.maybeHideModal();\n    });\n};\n/**\n * @param {!dialogPolyfillInfo} dpi\n * @return {boolean} whether the dialog was allowed\n */ $dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {\n    var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;\n    if (this.pendingDialogStack.length >= allowed) return false;\n    if (this.pendingDialogStack.unshift(dpi) === 1) this.blockDocument();\n    this.updateStacking();\n    return true;\n};\n/**\n * @param {!dialogPolyfillInfo} dpi\n */ $dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {\n    var index = this.pendingDialogStack.indexOf(dpi);\n    if (index === -1) return;\n    this.pendingDialogStack.splice(index, 1);\n    if (this.pendingDialogStack.length === 0) this.unblockDocument();\n    this.updateStacking();\n};\n$dc0f79ca3b6ad5d8$var$dialogPolyfill.dm = new $dc0f79ca3b6ad5d8$var$dialogPolyfill.DialogManager();\n$dc0f79ca3b6ad5d8$var$dialogPolyfill.formSubmitter = null;\n$dc0f79ca3b6ad5d8$var$dialogPolyfill.imagemapUseValue = null;\n/**\n * Installs global handlers, such as click listers and native method overrides. These are needed\n * even if a no dialog is registered, as they deal with <form method=\"dialog\">.\n */ if (window.HTMLDialogElement === undefined) {\n    /**\n   * If HTMLFormElement translates method=\"DIALOG\" into 'get', then replace the descriptor with\n   * one that returns the correct value.\n   */ var $dc0f79ca3b6ad5d8$var$testForm = document.createElement(\"form\");\n    $dc0f79ca3b6ad5d8$var$testForm.setAttribute(\"method\", \"dialog\");\n    if ($dc0f79ca3b6ad5d8$var$testForm.method !== \"dialog\") {\n        var $dc0f79ca3b6ad5d8$var$methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, \"method\");\n        if ($dc0f79ca3b6ad5d8$var$methodDescriptor) {\n            // nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything\n            // and don't bother to update the element.\n            var $dc0f79ca3b6ad5d8$var$realGet = $dc0f79ca3b6ad5d8$var$methodDescriptor.get;\n            $dc0f79ca3b6ad5d8$var$methodDescriptor.get = function() {\n                if ($dc0f79ca3b6ad5d8$var$isFormMethodDialog(this)) return \"dialog\";\n                return $dc0f79ca3b6ad5d8$var$realGet.call(this);\n            };\n            var $dc0f79ca3b6ad5d8$var$realSet = $dc0f79ca3b6ad5d8$var$methodDescriptor.set;\n            /** @this {HTMLElement} */ $dc0f79ca3b6ad5d8$var$methodDescriptor.set = function(v) {\n                if (typeof v === \"string\" && v.toLowerCase() === \"dialog\") return this.setAttribute(\"method\", v);\n                return $dc0f79ca3b6ad5d8$var$realSet.call(this, v);\n            };\n            Object.defineProperty(HTMLFormElement.prototype, \"method\", $dc0f79ca3b6ad5d8$var$methodDescriptor);\n        }\n    }\n    /**\n   * Global 'click' handler, to capture the <input type=\"submit\"> or <button> element which has\n   * submitted a <form method=\"dialog\">. Needed as Safari and others don't report this inside\n   * document.activeElement.\n   */ document.addEventListener(\"click\", function(ev) {\n        $dc0f79ca3b6ad5d8$var$dialogPolyfill.formSubmitter = null;\n        $dc0f79ca3b6ad5d8$var$dialogPolyfill.imagemapUseValue = null;\n        if (ev.defaultPrevented) return;\n         // e.g. a submit which prevents default submission\n        var target = /** @type {Element} */ ev.target;\n        if (\"composedPath\" in ev) {\n            var path = ev.composedPath();\n            target = path.shift() || target;\n        }\n        if (!target || !$dc0f79ca3b6ad5d8$var$isFormMethodDialog(target.form)) return;\n        var valid = target.type === \"submit\" && [\n            \"button\",\n            \"input\"\n        ].indexOf(target.localName) > -1;\n        if (!valid) {\n            if (!(target.localName === \"input\" && target.type === \"image\")) return;\n            // this is a <input type=\"image\">, which can submit forms\n            $dc0f79ca3b6ad5d8$var$dialogPolyfill.imagemapUseValue = ev.offsetX + \",\" + ev.offsetY;\n        }\n        var dialog = $dc0f79ca3b6ad5d8$var$findNearestDialog(target);\n        if (!dialog) return;\n        $dc0f79ca3b6ad5d8$var$dialogPolyfill.formSubmitter = target;\n    }, false);\n    /**\n   * Global 'submit' handler. This handles submits of `method=\"dialog\"` which are invalid, i.e.,\n   * outside a dialog. They get prevented.\n   */ document.addEventListener(\"submit\", function(ev) {\n        var form = ev.target;\n        var dialog = $dc0f79ca3b6ad5d8$var$findNearestDialog(form);\n        if (dialog) return; // ignore, handle there\n        var submitter = $dc0f79ca3b6ad5d8$var$findFormSubmitter(ev);\n        var formmethod = submitter && submitter.getAttribute(\"formmethod\") || form.getAttribute(\"method\");\n        if (formmethod === \"dialog\") ev.preventDefault();\n    });\n    /**\n   * Replace the native HTMLFormElement.submit() method, as it won't fire the\n   * submit event and give us a chance to respond.\n   */ var $dc0f79ca3b6ad5d8$var$nativeFormSubmit = HTMLFormElement.prototype.submit;\n    var $dc0f79ca3b6ad5d8$var$replacementFormSubmit = function() {\n        if (!$dc0f79ca3b6ad5d8$var$isFormMethodDialog(this)) return $dc0f79ca3b6ad5d8$var$nativeFormSubmit.call(this);\n        var dialog = $dc0f79ca3b6ad5d8$var$findNearestDialog(this);\n        dialog && dialog.close();\n    };\n    HTMLFormElement.prototype.submit = $dc0f79ca3b6ad5d8$var$replacementFormSubmit;\n}\nvar $dc0f79ca3b6ad5d8$export$2e2bcd8739ae039 = $dc0f79ca3b6ad5d8$var$dialogPolyfill;\n\n});\n\n\n//# sourceMappingURL=dialog-polyfill.esm.377e4aa1.js.map\n","// nb. This is for IE10 and lower _only_.\nvar supportCustomEvent = window.CustomEvent;\nif (!supportCustomEvent || typeof supportCustomEvent === 'object') {\n  supportCustomEvent = function CustomEvent(event, x) {\n    x = x || {};\n    var ev = document.createEvent('CustomEvent');\n    ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);\n    return ev;\n  };\n  supportCustomEvent.prototype = window.Event.prototype;\n}\n\n/**\n * Dispatches the passed event to both an \"on<type>\" handler as well as via the\n * normal dispatch operation. Does not bubble.\n *\n * @param {!EventTarget} target\n * @param {!Event} event\n * @return {boolean}\n */\nfunction safeDispatchEvent(target, event) {\n  var check = 'on' + event.type.toLowerCase();\n  if (typeof target[check] === 'function') {\n    target[check](event);\n  }\n  return target.dispatchEvent(event);\n}\n\n/**\n * @param {Element} el to check for stacking context\n * @return {boolean} whether this el or its parents creates a stacking context\n */\nfunction createsStackingContext(el) {\n  while (el && el !== document.body) {\n    var s = window.getComputedStyle(el);\n    var invalid = function(k, ok) {\n      return !(s[k] === undefined || s[k] === ok);\n    };\n\n    if (s.opacity < 1 ||\n        invalid('zIndex', 'auto') ||\n        invalid('transform', 'none') ||\n        invalid('mixBlendMode', 'normal') ||\n        invalid('filter', 'none') ||\n        invalid('perspective', 'none') ||\n        s['isolation'] === 'isolate' ||\n        s.position === 'fixed' ||\n        s.webkitOverflowScrolling === 'touch') {\n      return true;\n    }\n    el = el.parentElement;\n  }\n  return false;\n}\n\n/**\n * Finds the nearest <dialog> from the passed element.\n *\n * @param {Element} el to search from\n * @return {HTMLDialogElement} dialog found\n */\nfunction findNearestDialog(el) {\n  while (el) {\n    if (el.localName === 'dialog') {\n      return /** @type {HTMLDialogElement} */ (el);\n    }\n    if (el.parentElement) {\n      el = el.parentElement;\n    } else if (el.parentNode) {\n      el = el.parentNode.host;\n    } else {\n      el = null;\n    }\n  }\n  return null;\n}\n\n/**\n * Blur the specified element, as long as it's not the HTML body element.\n * This works around an IE9/10 bug - blurring the body causes Windows to\n * blur the whole application.\n *\n * @param {Element} el to blur\n */\nfunction safeBlur(el) {\n  // Find the actual focused element when the active element is inside a shadow root\n  while (el && el.shadowRoot && el.shadowRoot.activeElement) {\n    el = el.shadowRoot.activeElement;\n  }\n\n  if (el && el.blur && el !== document.body) {\n    el.blur();\n  }\n}\n\n/**\n * @param {!NodeList} nodeList to search\n * @param {Node} node to find\n * @return {boolean} whether node is inside nodeList\n */\nfunction inNodeList(nodeList, node) {\n  for (var i = 0; i < nodeList.length; ++i) {\n    if (nodeList[i] === node) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @param {HTMLFormElement} el to check\n * @return {boolean} whether this form has method=\"dialog\"\n */\nfunction isFormMethodDialog(el) {\n  if (!el || !el.hasAttribute('method')) {\n    return false;\n  }\n  return el.getAttribute('method').toLowerCase() === 'dialog';\n}\n\n/**\n * @param {!DocumentFragment|!Element} hostElement\n * @return {?Element}\n */\nfunction findFocusableElementWithin(hostElement) {\n  // Note that this is 'any focusable area'. This list is probably not exhaustive, but the\n  // alternative involves stepping through and trying to focus everything.\n  var opts = ['button', 'input', 'keygen', 'select', 'textarea'];\n  var query = opts.map(function(el) {\n    return el + ':not([disabled])';\n  });\n  // TODO(samthor): tabindex values that are not numeric are not focusable.\n  query.push('[tabindex]:not([disabled]):not([tabindex=\"\"])');  // tabindex != \"\", not disabled\n  var target = hostElement.querySelector(query.join(', '));\n\n  if (!target && 'attachShadow' in Element.prototype) {\n    // If we haven't found a focusable target, see if the host element contains an element\n    // which has a shadowRoot.\n    // Recursively search for the first focusable item in shadow roots.\n    var elems = hostElement.querySelectorAll('*');\n    for (var i = 0; i < elems.length; i++) {\n      if (elems[i].tagName && elems[i].shadowRoot) {\n        target = findFocusableElementWithin(elems[i].shadowRoot);\n        if (target) {\n          break;\n        }\n      }\n    }\n  }\n  return target;\n}\n\n/**\n * Determines if an element is attached to the DOM.\n * @param {Element} element to check\n * @return {boolean} whether the element is in DOM\n */\nfunction isConnected(element) {\n  return element.isConnected || document.body.contains(element);\n}\n\n/**\n * @param {!Event} event\n * @return {?Element}\n */\nfunction findFormSubmitter(event) {\n  if (event.submitter) {\n    return event.submitter;\n  }\n\n  var form = event.target;\n  if (!(form instanceof HTMLFormElement)) {\n    return null;\n  }\n\n  var submitter = dialogPolyfill.formSubmitter;\n  if (!submitter) {\n    var target = event.target;\n    var root = ('getRootNode' in target && target.getRootNode() || document);\n    submitter = root.activeElement;\n  }\n\n  if (!submitter || submitter.form !== form) {\n    return null;\n  }\n  return submitter;\n}\n\n/**\n * @param {!Event} event\n */\nfunction maybeHandleSubmit(event) {\n  if (event.defaultPrevented) {\n    return;\n  }\n  var form = /** @type {!HTMLFormElement} */ (event.target);\n\n  // We'd have a value if we clicked on an imagemap.\n  var value = dialogPolyfill.imagemapUseValue;\n  var submitter = findFormSubmitter(event);\n  if (value === null && submitter) {\n    value = submitter.value;\n  }\n\n  // There should always be a dialog as this handler is added specifically on them, but check just\n  // in case.\n  var dialog = findNearestDialog(form);\n  if (!dialog) {\n    return;\n  }\n\n  // Prefer formmethod on the button.\n  var formmethod = submitter && submitter.getAttribute('formmethod') || form.getAttribute('method');\n  if (formmethod !== 'dialog') {\n    return;\n  }\n  event.preventDefault();\n\n  if (value != null) {\n    // nb. we explicitly check against null/undefined\n    dialog.close(value);\n  } else {\n    dialog.close();\n  }\n}\n\n/**\n * @param {!HTMLDialogElement} dialog to upgrade\n * @constructor\n */\nfunction dialogPolyfillInfo(dialog) {\n  this.dialog_ = dialog;\n  this.replacedStyleTop_ = false;\n  this.openAsModal_ = false;\n\n  // Set a11y role. Browsers that support dialog implicitly know this already.\n  if (!dialog.hasAttribute('role')) {\n    dialog.setAttribute('role', 'dialog');\n  }\n\n  dialog.show = this.show.bind(this);\n  dialog.showModal = this.showModal.bind(this);\n  dialog.close = this.close.bind(this);\n\n  dialog.addEventListener('submit', maybeHandleSubmit, false);\n\n  if (!('returnValue' in dialog)) {\n    dialog.returnValue = '';\n  }\n\n  if ('MutationObserver' in window) {\n    var mo = new MutationObserver(this.maybeHideModal.bind(this));\n    mo.observe(dialog, {attributes: true, attributeFilter: ['open']});\n  } else {\n    // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also\n    // seem to fire even if the element was removed as part of a parent removal. Use the removed\n    // events to force downgrade (useful if removed/immediately added).\n    var removed = false;\n    var cb = function() {\n      removed ? this.downgradeModal() : this.maybeHideModal();\n      removed = false;\n    }.bind(this);\n    var timeout;\n    var delayModel = function(ev) {\n      if (ev.target !== dialog) { return; }  // not for a child element\n      var cand = 'DOMNodeRemoved';\n      removed |= (ev.type.substr(0, cand.length) === cand);\n      window.clearTimeout(timeout);\n      timeout = window.setTimeout(cb, 0);\n    };\n    ['DOMAttrModified', 'DOMNodeRemoved', 'DOMNodeRemovedFromDocument'].forEach(function(name) {\n      dialog.addEventListener(name, delayModel);\n    });\n  }\n  // Note that the DOM is observed inside DialogManager while any dialog\n  // is being displayed as a modal, to catch modal removal from the DOM.\n\n  Object.defineProperty(dialog, 'open', {\n    set: this.setOpen.bind(this),\n    get: dialog.hasAttribute.bind(dialog, 'open')\n  });\n\n  this.backdrop_ = document.createElement('div');\n  this.backdrop_.className = 'backdrop';\n  this.backdrop_.addEventListener('mouseup'  , this.backdropMouseEvent_.bind(this));\n  this.backdrop_.addEventListener('mousedown', this.backdropMouseEvent_.bind(this));\n  this.backdrop_.addEventListener('click'    , this.backdropMouseEvent_.bind(this));\n}\n\ndialogPolyfillInfo.prototype = /** @type {HTMLDialogElement.prototype} */ ({\n\n  get dialog() {\n    return this.dialog_;\n  },\n\n  /**\n   * Maybe remove this dialog from the modal top layer. This is called when\n   * a modal dialog may no longer be tenable, e.g., when the dialog is no\n   * longer open or is no longer part of the DOM.\n   */\n  maybeHideModal: function() {\n    if (this.dialog_.hasAttribute('open') && isConnected(this.dialog_)) { return; }\n    this.downgradeModal();\n  },\n\n  /**\n   * Remove this dialog from the modal top layer, leaving it as a non-modal.\n   */\n  downgradeModal: function() {\n    if (!this.openAsModal_) { return; }\n    this.openAsModal_ = false;\n    this.dialog_.style.zIndex = '';\n\n    // This won't match the native <dialog> exactly because if the user set top on a centered\n    // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's\n    // possible to polyfill this perfectly.\n    if (this.replacedStyleTop_) {\n      this.dialog_.style.top = '';\n      this.replacedStyleTop_ = false;\n    }\n\n    // Clear the backdrop and remove from the manager.\n    this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);\n    dialogPolyfill.dm.removeDialog(this);\n  },\n\n  /**\n   * @param {boolean} value whether to open or close this dialog\n   */\n  setOpen: function(value) {\n    if (value) {\n      this.dialog_.hasAttribute('open') || this.dialog_.setAttribute('open', '');\n    } else {\n      this.dialog_.removeAttribute('open');\n      this.maybeHideModal();  // nb. redundant with MutationObserver\n    }\n  },\n\n  /**\n   * Handles mouse events ('mouseup', 'mousedown', 'click') on the fake .backdrop element, redirecting them as if\n   * they were on the dialog itself.\n   *\n   * @param {!Event} e to redirect\n   */\n  backdropMouseEvent_: function(e) {\n    if (!this.dialog_.hasAttribute('tabindex')) {\n      // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be\n      // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this\n      // would not be needed - clicks would move the implicit cursor there.\n      var fake = document.createElement('div');\n      this.dialog_.insertBefore(fake, this.dialog_.firstChild);\n      fake.tabIndex = -1;\n      fake.focus();\n      this.dialog_.removeChild(fake);\n    } else {\n      this.dialog_.focus();\n    }\n\n    var redirectedEvent = document.createEvent('MouseEvents');\n    redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window,\n        e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey,\n        e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n    this.dialog_.dispatchEvent(redirectedEvent);\n    e.stopPropagation();\n  },\n\n  /**\n   * Focuses on the first focusable element within the dialog. This will always blur the current\n   * focus, even if nothing within the dialog is found.\n   */\n  focus_: function() {\n    // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.\n    var target = this.dialog_.querySelector('[autofocus]:not([disabled])');\n    if (!target && this.dialog_.tabIndex >= 0) {\n      target = this.dialog_;\n    }\n    if (!target) {\n      target = findFocusableElementWithin(this.dialog_);\n    }\n    safeBlur(document.activeElement);\n    target && target.focus();\n  },\n\n  /**\n   * Sets the zIndex for the backdrop and dialog.\n   *\n   * @param {number} dialogZ\n   * @param {number} backdropZ\n   */\n  updateZIndex: function(dialogZ, backdropZ) {\n    if (dialogZ < backdropZ) {\n      throw new Error('dialogZ should never be < backdropZ');\n    }\n    this.dialog_.style.zIndex = dialogZ;\n    this.backdrop_.style.zIndex = backdropZ;\n  },\n\n  /**\n   * Shows the dialog. If the dialog is already open, this does nothing.\n   */\n  show: function() {\n    if (!this.dialog_.open) {\n      this.setOpen(true);\n      this.focus_();\n    }\n  },\n\n  /**\n   * Show this dialog modally.\n   */\n  showModal: function() {\n    if (this.dialog_.hasAttribute('open')) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: The element is already open, and therefore cannot be opened modally.');\n    }\n    if (!isConnected(this.dialog_)) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: The element is not in a Document.');\n    }\n    if (!dialogPolyfill.dm.pushDialog(this)) {\n      throw new Error('Failed to execute \\'showModal\\' on dialog: There are too many open modal dialogs.');\n    }\n\n    if (createsStackingContext(this.dialog_.parentElement)) {\n      console.warn('A dialog is being shown inside a stacking context. ' +\n          'This may cause it to be unusable. For more information, see this link: ' +\n          'https://github.com/GoogleChrome/dialog-polyfill/#stacking-context');\n    }\n\n    this.setOpen(true);\n    this.openAsModal_ = true;\n\n    // Optionally center vertically, relative to the current viewport.\n    if (dialogPolyfill.needsCentering(this.dialog_)) {\n      dialogPolyfill.reposition(this.dialog_);\n      this.replacedStyleTop_ = true;\n    } else {\n      this.replacedStyleTop_ = false;\n    }\n\n    // Insert backdrop.\n    this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);\n\n    // Focus on whatever inside the dialog.\n    this.focus_();\n  },\n\n  /**\n   * Closes this HTMLDialogElement. This is optional vs clearing the open\n   * attribute, however this fires a 'close' event.\n   *\n   * @param {string=} opt_returnValue to use as the returnValue\n   */\n  close: function(opt_returnValue) {\n    if (!this.dialog_.hasAttribute('open')) {\n      throw new Error('Failed to execute \\'close\\' on dialog: The element does not have an \\'open\\' attribute, and therefore cannot be closed.');\n    }\n    this.setOpen(false);\n\n    // Leave returnValue untouched in case it was set directly on the element\n    if (opt_returnValue !== undefined) {\n      this.dialog_.returnValue = opt_returnValue;\n    }\n\n    // Triggering \"close\" event for any attached listeners on the <dialog>.\n    var closeEvent = new supportCustomEvent('close', {\n      bubbles: false,\n      cancelable: false\n    });\n    safeDispatchEvent(this.dialog_, closeEvent);\n  }\n\n});\n\nvar dialogPolyfill = {};\n\ndialogPolyfill.reposition = function(element) {\n  var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;\n  element.style.top = Math.max(scrollTop, topValue) + 'px';\n};\n\ndialogPolyfill.isInlinePositionSetByStylesheet = function(element) {\n  for (var i = 0; i < document.styleSheets.length; ++i) {\n    var styleSheet = document.styleSheets[i];\n    var cssRules = null;\n    // Some browsers throw on cssRules.\n    try {\n      cssRules = styleSheet.cssRules;\n    } catch (e) {}\n    if (!cssRules) { continue; }\n    for (var j = 0; j < cssRules.length; ++j) {\n      var rule = cssRules[j];\n      var selectedNodes = null;\n      // Ignore errors on invalid selector texts.\n      try {\n        selectedNodes = document.querySelectorAll(rule.selectorText);\n      } catch(e) {}\n      if (!selectedNodes || !inNodeList(selectedNodes, element)) {\n        continue;\n      }\n      var cssTop = rule.style.getPropertyValue('top');\n      var cssBottom = rule.style.getPropertyValue('bottom');\n      if ((cssTop && cssTop !== 'auto') || (cssBottom && cssBottom !== 'auto')) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\ndialogPolyfill.needsCentering = function(dialog) {\n  var computedStyle = window.getComputedStyle(dialog);\n  if (computedStyle.position !== 'absolute') {\n    return false;\n  }\n\n  // We must determine whether the top/bottom specified value is non-auto.  In\n  // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but\n  // Firefox returns the used value. So we do this crazy thing instead: check\n  // the inline style and then go through CSS rules.\n  if ((dialog.style.top !== 'auto' && dialog.style.top !== '') ||\n      (dialog.style.bottom !== 'auto' && dialog.style.bottom !== '')) {\n    return false;\n  }\n  return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);\n};\n\n/**\n * @param {!Element} element to force upgrade\n */\ndialogPolyfill.forceRegisterDialog = function(element) {\n  if (window.HTMLDialogElement || element.showModal) {\n    console.warn('This browser already supports <dialog>, the polyfill ' +\n        'may not work correctly', element);\n  }\n  if (element.localName !== 'dialog') {\n    throw new Error('Failed to register dialog: The element is not a dialog.');\n  }\n  new dialogPolyfillInfo(/** @type {!HTMLDialogElement} */ (element));\n};\n\n/**\n * @param {!Element} element to upgrade, if necessary\n */\ndialogPolyfill.registerDialog = function(element) {\n  if (!element.showModal) {\n    dialogPolyfill.forceRegisterDialog(element);\n  }\n};\n\n/**\n * @constructor\n */\ndialogPolyfill.DialogManager = function() {\n  /** @type {!Array<!dialogPolyfillInfo>} */\n  this.pendingDialogStack = [];\n\n  var checkDOM = this.checkDOM_.bind(this);\n\n  // The overlay is used to simulate how a modal dialog blocks the document.\n  // The blocking dialog is positioned on top of the overlay, and the rest of\n  // the dialogs on the pending dialog stack are positioned below it. In the\n  // actual implementation, the modal dialog stacking is controlled by the\n  // top layer, where z-index has no effect.\n  this.overlay = document.createElement('div');\n  this.overlay.className = '_dialog_overlay';\n  this.overlay.addEventListener('click', function(e) {\n    this.forwardTab_ = undefined;\n    e.stopPropagation();\n    checkDOM([]);  // sanity-check DOM\n  }.bind(this));\n\n  this.handleKey_ = this.handleKey_.bind(this);\n  this.handleFocus_ = this.handleFocus_.bind(this);\n\n  this.zIndexLow_ = 100000;\n  this.zIndexHigh_ = 100000 + 150;\n\n  this.forwardTab_ = undefined;\n\n  if ('MutationObserver' in window) {\n    this.mo_ = new MutationObserver(function(records) {\n      var removed = [];\n      records.forEach(function(rec) {\n        for (var i = 0, c; c = rec.removedNodes[i]; ++i) {\n          if (!(c instanceof Element)) {\n            continue;\n          } else if (c.localName === 'dialog') {\n            removed.push(c);\n          }\n          removed = removed.concat(c.querySelectorAll('dialog'));\n        }\n      });\n      removed.length && checkDOM(removed);\n    });\n  }\n};\n\n/**\n * Called on the first modal dialog being shown. Adds the overlay and related\n * handlers.\n */\ndialogPolyfill.DialogManager.prototype.blockDocument = function() {\n  document.documentElement.addEventListener('focus', this.handleFocus_, true);\n  document.addEventListener('keydown', this.handleKey_);\n  this.mo_ && this.mo_.observe(document, {childList: true, subtree: true});\n};\n\n/**\n * Called on the first modal dialog being removed, i.e., when no more modal\n * dialogs are visible.\n */\ndialogPolyfill.DialogManager.prototype.unblockDocument = function() {\n  document.documentElement.removeEventListener('focus', this.handleFocus_, true);\n  document.removeEventListener('keydown', this.handleKey_);\n  this.mo_ && this.mo_.disconnect();\n};\n\n/**\n * Updates the stacking of all known dialogs.\n */\ndialogPolyfill.DialogManager.prototype.updateStacking = function() {\n  var zIndex = this.zIndexHigh_;\n\n  for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {\n    dpi.updateZIndex(--zIndex, --zIndex);\n    if (i === 0) {\n      this.overlay.style.zIndex = --zIndex;\n    }\n  }\n\n  // Make the overlay a sibling of the dialog itself.\n  var last = this.pendingDialogStack[0];\n  if (last) {\n    var p = last.dialog.parentNode || document.body;\n    p.appendChild(this.overlay);\n  } else if (this.overlay.parentNode) {\n    this.overlay.parentNode.removeChild(this.overlay);\n  }\n};\n\n/**\n * @param {Element} candidate to check if contained or is the top-most modal dialog\n * @return {boolean} whether candidate is contained in top dialog\n */\ndialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {\n  while (candidate = findNearestDialog(candidate)) {\n    for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {\n      if (dpi.dialog === candidate) {\n        return i === 0;  // only valid if top-most\n      }\n    }\n    candidate = candidate.parentElement;\n  }\n  return false;\n};\n\ndialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {\n  var target = event.composedPath ? event.composedPath()[0] : event.target;\n\n  if (this.containedByTopDialog_(target)) { return; }\n\n  if (document.activeElement === document.documentElement) { return; }\n\n  event.preventDefault();\n  event.stopPropagation();\n  safeBlur(/** @type {Element} */ (target));\n\n  if (this.forwardTab_ === undefined) { return; }  // move focus only from a tab key\n\n  var dpi = this.pendingDialogStack[0];\n  var dialog = dpi.dialog;\n  var position = dialog.compareDocumentPosition(target);\n  if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n    if (this.forwardTab_) {\n      // forward\n      dpi.focus_();\n    } else if (target !== document.documentElement) {\n      // backwards if we're not already focused on <html>\n      document.documentElement.focus();\n    }\n  }\n\n  return false;\n};\n\ndialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {\n  this.forwardTab_ = undefined;\n  if (event.keyCode === 27) {\n    event.preventDefault();\n    event.stopPropagation();\n    var cancelEvent = new supportCustomEvent('cancel', {\n      bubbles: false,\n      cancelable: true\n    });\n    var dpi = this.pendingDialogStack[0];\n    if (dpi && safeDispatchEvent(dpi.dialog, cancelEvent)) {\n      dpi.dialog.close();\n    }\n  } else if (event.keyCode === 9) {\n    this.forwardTab_ = !event.shiftKey;\n  }\n};\n\n/**\n * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are\n * removed and immediately readded don't stay modal, they become normal.\n *\n * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed\n */\ndialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {\n  // This operates on a clone because it may cause it to change. Each change also calls\n  // updateStacking, which only actually needs to happen once. But who removes many modal dialogs\n  // at a time?!\n  var clone = this.pendingDialogStack.slice();\n  clone.forEach(function(dpi) {\n    if (removed.indexOf(dpi.dialog) !== -1) {\n      dpi.downgradeModal();\n    } else {\n      dpi.maybeHideModal();\n    }\n  });\n};\n\n/**\n * @param {!dialogPolyfillInfo} dpi\n * @return {boolean} whether the dialog was allowed\n */\ndialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {\n  var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;\n  if (this.pendingDialogStack.length >= allowed) {\n    return false;\n  }\n  if (this.pendingDialogStack.unshift(dpi) === 1) {\n    this.blockDocument();\n  }\n  this.updateStacking();\n  return true;\n};\n\n/**\n * @param {!dialogPolyfillInfo} dpi\n */\ndialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {\n  var index = this.pendingDialogStack.indexOf(dpi);\n  if (index === -1) { return; }\n\n  this.pendingDialogStack.splice(index, 1);\n  if (this.pendingDialogStack.length === 0) {\n    this.unblockDocument();\n  }\n  this.updateStacking();\n};\n\ndialogPolyfill.dm = new dialogPolyfill.DialogManager();\ndialogPolyfill.formSubmitter = null;\ndialogPolyfill.imagemapUseValue = null;\n\n/**\n * Installs global handlers, such as click listers and native method overrides. These are needed\n * even if a no dialog is registered, as they deal with <form method=\"dialog\">.\n */\nif (window.HTMLDialogElement === undefined) {\n\n  /**\n   * If HTMLFormElement translates method=\"DIALOG\" into 'get', then replace the descriptor with\n   * one that returns the correct value.\n   */\n  var testForm = document.createElement('form');\n  testForm.setAttribute('method', 'dialog');\n  if (testForm.method !== 'dialog') {\n    var methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'method');\n    if (methodDescriptor) {\n      // nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything\n      // and don't bother to update the element.\n      var realGet = methodDescriptor.get;\n      methodDescriptor.get = function() {\n        if (isFormMethodDialog(this)) {\n          return 'dialog';\n        }\n        return realGet.call(this);\n      };\n      var realSet = methodDescriptor.set;\n      /** @this {HTMLElement} */\n      methodDescriptor.set = function(v) {\n        if (typeof v === 'string' && v.toLowerCase() === 'dialog') {\n          return this.setAttribute('method', v);\n        }\n        return realSet.call(this, v);\n      };\n      Object.defineProperty(HTMLFormElement.prototype, 'method', methodDescriptor);\n    }\n  }\n\n  /**\n   * Global 'click' handler, to capture the <input type=\"submit\"> or <button> element which has\n   * submitted a <form method=\"dialog\">. Needed as Safari and others don't report this inside\n   * document.activeElement.\n   */\n  document.addEventListener('click', function(ev) {\n    dialogPolyfill.formSubmitter = null;\n    dialogPolyfill.imagemapUseValue = null;\n    if (ev.defaultPrevented) { return; }  // e.g. a submit which prevents default submission\n\n    var target = /** @type {Element} */ (ev.target);\n    if ('composedPath' in ev) {\n      var path = ev.composedPath();\n      target = path.shift() || target;\n    }\n    if (!target || !isFormMethodDialog(target.form)) { return; }\n\n    var valid = (target.type === 'submit' && ['button', 'input'].indexOf(target.localName) > -1);\n    if (!valid) {\n      if (!(target.localName === 'input' && target.type === 'image')) { return; }\n      // this is a <input type=\"image\">, which can submit forms\n      dialogPolyfill.imagemapUseValue = ev.offsetX + ',' + ev.offsetY;\n    }\n\n    var dialog = findNearestDialog(target);\n    if (!dialog) { return; }\n\n    dialogPolyfill.formSubmitter = target;\n\n  }, false);\n\n  /**\n   * Global 'submit' handler. This handles submits of `method=\"dialog\"` which are invalid, i.e.,\n   * outside a dialog. They get prevented.\n   */\n  document.addEventListener('submit', function(ev) {\n    var form = ev.target;\n    var dialog = findNearestDialog(form);\n    if (dialog) {\n      return;  // ignore, handle there\n    }\n\n    var submitter = findFormSubmitter(ev);\n    var formmethod = submitter && submitter.getAttribute('formmethod') || form.getAttribute('method');\n    if (formmethod === 'dialog') {\n      ev.preventDefault();\n    }\n  });\n\n  /**\n   * Replace the native HTMLFormElement.submit() method, as it won't fire the\n   * submit event and give us a chance to respond.\n   */\n  var nativeFormSubmit = HTMLFormElement.prototype.submit;\n  var replacementFormSubmit = function () {\n    if (!isFormMethodDialog(this)) {\n      return nativeFormSubmit.call(this);\n    }\n    var dialog = findNearestDialog(this);\n    dialog && dialog.close();\n  };\n  HTMLFormElement.prototype.submit = replacementFormSubmit;\n}\n\nexport default dialogPolyfill;\n"],"names":["parcelRequire","$parcel$global","globalThis","register","module","exports","Object","defineProperty","get","$dc0f79ca3b6ad5d8$export$2e2bcd8739ae039","set","s","enumerable","configurable","$dc0f79ca3b6ad5d8$var$supportCustomEvent","window","CustomEvent","$dc0f79ca3b6ad5d8$var$safeDispatchEvent","target","event","check","type","toLowerCase","dispatchEvent","$dc0f79ca3b6ad5d8$var$findNearestDialog","el","localName","parentElement","parentNode","host","$dc0f79ca3b6ad5d8$var$safeBlur","shadowRoot","activeElement","blur","document","body","$dc0f79ca3b6ad5d8$var$isFormMethodDialog","hasAttribute","getAttribute","$dc0f79ca3b6ad5d8$var$isConnected","element","isConnected","contains","$dc0f79ca3b6ad5d8$var$findFormSubmitter","submitter","form","HTMLFormElement","$dc0f79ca3b6ad5d8$var$dialogPolyfill","formSubmitter","root","getRootNode","$dc0f79ca3b6ad5d8$var$maybeHandleSubmit","defaultPrevented","value","imagemapUseValue","dialog","formmethod","preventDefault","close","$dc0f79ca3b6ad5d8$var$dialogPolyfillInfo","dialog_","replacedStyleTop_","openAsModal_","setAttribute","show","bind","showModal","addEventListener","returnValue","mo","MutationObserver","maybeHideModal","observe","attributes","attributeFilter","timeout","removed","cb","downgradeModal","delayModel","ev","cand","substr","length","clearTimeout","setTimeout","forEach","name","setOpen","backdrop_","createElement","className","backdropMouseEvent_","x","createEvent","initCustomEvent","bubbles","cancelable","detail","prototype","Event","style","zIndex","top","removeChild","dm","removeDialog","removeAttribute","e","focus","fake","insertBefore","firstChild","tabIndex","redirectedEvent","initMouseEvent","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","stopPropagation","focus_","querySelector","$dc0f79ca3b6ad5d8$var$findFocusableElementWithin","hostElement","query","opts","map","push","join","Element","elems","querySelectorAll","i","tagName","updateZIndex","dialogZ","backdropZ","Error","open","pushDialog","$dc0f79ca3b6ad5d8$var$createsStackingContext","getComputedStyle","invalid","k","ok","undefined","opacity","position","webkitOverflowScrolling","console","warn","needsCentering","reposition","nextSibling","opt_returnValue","closeEvent","scrollTop","documentElement","topValue","innerHeight","offsetHeight","Math","max","isInlinePositionSetByStylesheet","styleSheets","styleSheet","cssRules","j","rule","selectedNodes","selectorText","$dc0f79ca3b6ad5d8$var$inNodeList","nodeList","node","cssTop","getPropertyValue","cssBottom","computedStyle","bottom","forceRegisterDialog","HTMLDialogElement","registerDialog","DialogManager","pendingDialogStack","checkDOM","checkDOM_","overlay","forwardTab_","handleKey_","handleFocus_","zIndexLow_","zIndexHigh_","mo_","records","rec","c","removedNodes","concat","blockDocument","childList","subtree","unblockDocument","removeEventListener","disconnect","updateStacking","dpi","last","p","appendChild","containedByTopDialog_","candidate","composedPath","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","keyCode","cancelEvent","clone","slice","indexOf","allowed","unshift","index","splice","$dc0f79ca3b6ad5d8$var$testForm","method","$dc0f79ca3b6ad5d8$var$methodDescriptor","getOwnPropertyDescriptor","$dc0f79ca3b6ad5d8$var$realGet","call","$dc0f79ca3b6ad5d8$var$realSet","v","path","shift","offsetX","offsetY","$dc0f79ca3b6ad5d8$var$nativeFormSubmit","submit"],"version":3,"file":"dialog-polyfill.esm.377e4aa1.js.map"}